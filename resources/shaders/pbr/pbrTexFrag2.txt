// The following code is based, and with some modifications, from :- 
// Joey de Vries (2020). Learn OpenGL [online]. [Accessed 6th November 2021].
// Available from: <https://learnopengl.com>.
//
// Brian Karis (2013). Specular BRDF Reference [online]. [Accessed 8th December 2021].
// Available from: <http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html>

#version 410

// Material properties
uniform vec3 albedo;
uniform float metallic;
uniform float roughness;
uniform float ao;

in vec3 v_WorldPos;
in vec2 v_TexCoord;
in vec3 v_Normal;

uniform vec3 lightPositions[4];
uniform vec3 lightColours[4];
uniform vec3 camPos;

out vec4 FragColour;

const float PI = 3.14159265359;

float BlinnPhong(vec3 _N, vec3 _H, float _roughness)
{
	float NdotH = max(dot(_N, _H), 0.0);
	float roughnessSqrd = _roughness * _roughness;
	float finalRoughness = roughnessSqrd * roughnessSqrd;
	
	float partOne = 1 / (PI * finalRoughness);
	float partTwo = pow(NdotH, (2 / finalRoughness) - 2);
	
	return partOne * partTwo;
}

vec3 fresnelSchlick(float _cosTheta, vec3 _F0)
{
    return _F0 + (1.0 - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
}


vec3 fresnelSchlickRoughness(float _cosTheta, vec3 _F0, float _roughness)
{
    return _F0 + (max(vec3(1.0 - _roughness), _F0) - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
} 

float GGXGSF(float _NdotV, float _roughness)
{
	// NOMINATOR
	//==========
	float nom = 2 * _NdotV;
	
	// DENOMINATOR
	//============
	float roughnessSqrd = _roughness * _roughness;
	float rootResult = sqrt(roughnessSqrd + (1 - roughnessSqrd) * (_NdotV * _NdotV));

	float denom = _NdotV + rootResult;

	return nom / denom;
}

float GeometrySmith(vec3 _N, vec3 _V, vec3 _L, float _roughness)
{
    float NdotV = max(dot(_N, _V), 0.0);
    float NdotL = max(dot(_N, _L), 0.0);
    float ggx2 = GGXGSF(NdotV, _roughness);
    float ggx1 = GGXGSF(NdotL, _roughness);

    return ggx1 * ggx2;
}

void main()											 
{	
	vec3 normVec = normalize(v_Normal);
	vec3 viewDir = normalize(camPos - v_WorldPos);

	// F0 is surface reflection; how much the surface reflects 
	// if looking directly at the surface.
	// For non-metallic surfaces
	vec3 F0 = vec3(0.04);	// Assume most dielectric surfaces to be correct at 0.04.

	// For metallic surfaces
	F0 = mix(F0, albedo, metallic);

	// REFLECTANCE EQUATION
	//=====================
	// total radiance of the scene (Lo)
	vec3 outgoingRadiance = vec3(0.0);
	for (int i = 0; i < 4; i++)
	{
		// PER-LIGHT RADIANCE
		//===================
		vec3 lightDir = normalize(lightPositions[i] - v_WorldPos);
		vec3 halfwayVec = normalize(viewDir + lightDir);

		// INVERSE-SQUARE LAW
		// When the distance increases, the intensity decreases. 
		// When the distance decreases, the intensity increases.
		//===================
		float distance = length(lightPositions[i] - v_WorldPos);
		float intensity = 1.0 / (distance * distance);
		vec3 radiance = lightColours[i] * intensity;

		// COOK-TORRANCE BRDF
		//===================
		float NDF = BlinnPhong(normVec, halfwayVec, roughness);
		float G = GeometrySmith(normVec, viewDir, lightDir, roughness);
		vec3 F = fresnelSchlick(max(dot(halfwayVec, viewDir), 0.0), F0);	// We pass through the half-way vector and view direction to create the cosTheta for fresnel

		// NUMERATOR
		//==========
		vec3 num = NDF * G * F;
		
		// DENOMINATOR
		//============
		float denom = 4 * max(dot(normVec, lightDir), 0.0) * max(dot(normVec, viewDir), 0.0) + 0.0001;	// prevent any divide by zero

		// COOK-TORRANCE RESULT
		//=====================
		vec3 specular = num / denom;

		// LIGHT CONTRIBUTION TO END RESULT
		//=================================
		// reflection/specular fraction (kS) is equal to Fresnel
		vec3 reflection = F;
		// refraction/diffuse fraction (kD)
		vec3 refraction = vec3(1.0) - reflection;	// stops it from exceeding 1.0, preserviing the energy conservation relationship

		// If the surface is metal, we invalidate the reflection due to the absorbtion of light.
		// Metals show no diffuse colour and leave refracted or specular light. 
		refraction *= 1.0 - metallic;

		// Scale light by NdotL
		float NdotL = max(dot(normVec, lightDir), 0.0);

		// Add to outgoing radiance
		outgoingRadiance += (refraction * albedo / PI + specular) * radiance * NdotL;	// Note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again
	}

	vec3 ambient = vec3(0.03) * albedo * ao;
	
	vec3 colour = ambient + outgoingRadiance;

	// HDR tonemapping
	colour = colour / (colour + vec3(1.0));

	// Gamma correct
	colour = pow(colour, vec3(1.0/2.2));

	// FINAL RESULT
	//=============
	FragColour = vec4(colour, 1.0);
}