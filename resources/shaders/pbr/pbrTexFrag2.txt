// The following code is based, and with some modifications, from :- 
// Joey de Vries (2020). Learn OpenGL [online]. [Accessed 6th November 2021].
// Available from: <https://learnopengl.com>.
//
// Brian Karis (2013). Specular BRDF Reference [online]. [Accessed 8th December 2021].
// Available from: <http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html>

#version 410

// Material properties
uniform vec3 albedo;
uniform float metallic;
uniform float roughness;
uniform float ao;

in vec3 v_WorldPos;
in vec2 v_TexCoord;
in vec3 v_Normal;

uniform vec3 lightPositions[4];
uniform vec3 lightColours[4];
uniform vec3 camPos;

out vec4 FragColour;

const float PI = 3.14159265359;

float BlinnPhong(vec3 _N, vec3 _H, float _roughness)
{
	// PREREQUISITES
	//==============
	float NdotH = max(dot(_N, _H), 0.0);
	float alpha = _roughness * _roughness;
	float alphaSqrd = alpha * alpha;
	
	float partOne = 1 / (PI * alphaSqrd);
	float partTwo = max(pow(NdotH, (2 / alphaSqrd) - 2), 0.0);
	
	return partOne * partTwo;
}

vec3 fresnelSchlick(float _cosTheta, vec3 _F0)
{
    return _F0 + (1.0 - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
}


vec3 fresnelSchlickRoughness(float _cosTheta, vec3 _F0, float _roughness)
{
    return _F0 + (max(vec3(1.0 - _roughness), _F0) - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
} 

float GeometryBeckmann(float _NdotV, float _roughness)
{
	// PREREQUISITES
	//==============
	float alpha = _roughness * _roughness;
	float NdotVSqrd = _NdotV * _NdotV;

	// NUMERATOR
	//==========
	float num = NdotVSqrd;

	// DENOMINATOR
	//============
	float sqrtVal = 1.0 - NdotVSqrd;
	float denom = alpha * sqrtVal;

	float C = NdotVSqrd / denom;

	// 1.6 CHECK
	if (C < 1.6)
	{
		// NUMERATOR #2
		//=============
		float numP1 = 3.535 * C;
		float numP2 = 2.181 * C;
		float numP2Sqrd = numP2 * numP2;
		float finalNum = numP1 + numP2Sqrd;

		// DENOMINATOR #2
		//===============
		float denomP1 = 1.0 + 2.276 * C;
		float denomP2 = 2.577 * C;
		float denomP2Sqrd = denomP2 * denomP2;
		float finalDenom = denomP1 + denomP2Sqrd;

		return finalNum / finalDenom;
	}
	else if (C >= 1.6)
	{
		return 1.0;
	}

	return 0.0;
}

// Smith breaks the GGX down into two parts; lightDir and viewDir.
// They both execute the same equations.
float GeometrySmith(vec3 _normVec, vec3 _viewDir, vec3 _lightDir, float _roughness)
{
	// PART ONE
	//=========
    float NdotL = max(dot(_normVec, _lightDir), 0.0);
	float ggxPartOne = GeometryBeckmann(NdotL, _roughness);

	// PART TWO
	//=========
	float NdotV = max(dot(_normVec, _viewDir), 0.0);
    float ggxPartTwo = GeometryBeckmann(NdotV, _roughness);
	
	// RESULT
	//=======
    return ggxPartOne * ggxPartTwo;
}

void main()											 
{	
	vec3 normVec = normalize(v_Normal);
	vec3 viewDir = normalize(camPos - v_WorldPos);

	// F0 is surface reflection; how much the surface reflects 
	// if looking directly at the surface.
	// For non-metallic surfaces
	vec3 F0 = vec3(0.04);	// Assume most dielectric surfaces to be correct at 0.04.

	// For metallic surfaces
	F0 = mix(F0, albedo, metallic);

	// REFLECTANCE EQUATION
	//=====================
	// total radiance of the scene (Lo)
	vec3 outgoingRadiance = vec3(0.0);
	for (int i = 0; i < 4; i++)
	{
		// PER-LIGHT RADIANCE
		//===================
		vec3 lightDir = normalize(lightPositions[i] - v_WorldPos);
		vec3 halfwayVec = normalize(viewDir + lightDir);

		// INVERSE-SQUARE LAW
		// When the distance increases, the intensity decreases. 
		// When the distance decreases, the intensity increases.
		//===================
		float distance = length(lightPositions[i] - v_WorldPos);
		float intensity = 1.0 / (distance * distance);
		vec3 radiance = lightColours[i] * intensity;

		// COOK-TORRANCE BRDF
		//===================
		float NDF = BlinnPhong(normVec, halfwayVec, roughness);
		float G = GeometrySmith(normVec, viewDir, lightDir, roughness);
		vec3 F = fresnelSchlick(max(dot(halfwayVec, viewDir), 0.0), F0);	// We pass through the half-way vector and view direction to create the cosTheta for fresnel

		// NUMERATOR
		//==========
		vec3 num = NDF * G * F;
		
		// DENOMINATOR
		//============
		float denom = 4 * max(dot(normVec, lightDir), 0.0) * max(dot(normVec, viewDir), 0.0) + 0.0001;	// prevent any divide by zero

		// COOK-TORRANCE RESULT
		//=====================
		vec3 specular = num / denom;

		// LIGHT CONTRIBUTION TO END RESULT
		//=================================
		// reflection/specular fraction (kS) is equal to Fresnel
		vec3 reflection = F;
		// refraction/diffuse fraction (kD)
		vec3 refraction = vec3(1.0) - reflection;	// stops it from exceeding 1.0, preserviing the energy conservation relationship

		// If the surface is metal, we invalidate the reflection due to the absorbtion of light.
		// Metals show no diffuse colour and leave refracted or specular light. 
		refraction *= 1.0 - metallic;

		// Scale light by NdotL
		float NdotL = max(dot(normVec, lightDir), 0.0);

		// Add to outgoing radiance
		outgoingRadiance += (refraction * albedo / PI + specular) * radiance * NdotL;	// Note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again
	}

	vec3 ambient = vec3(0.03) * albedo * ao;
	
	vec3 colour = ambient + outgoingRadiance;

	// HDR tonemapping
	colour = colour / (colour + vec3(1.0));

	// Gamma correct
	colour = pow(colour, vec3(1.0/2.2));

	// FINAL RESULT
	//=============
	FragColour = vec4(colour, 1.0);
}