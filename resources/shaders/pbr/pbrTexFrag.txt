// The following code is based, and with some modifications, from :- 
// Joey de Vries (2020). Learn OpenGL [online]. [Accessed 6th November 2021].
// Available from: <https://learnopengl.com>.
//
// Brian Karis (2013). Specular BRDF Reference [online]. [Accessed 8th December 2021].
// Available from: <http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html>

#version 410

// Material properties
uniform sampler2D albedoMap;
uniform sampler2D normalMap;
uniform sampler2D metallicMap;
uniform sampler2D roughnessMap;
uniform sampler2D aoMap;

in vec3 v_WorldPos;
in vec2 v_TexCoord;
in vec3 v_Normal;

// IBL
uniform samplerCube irradianceMap;
uniform samplerCube prefilterMap;
uniform sampler2D brdfLUT;

uniform vec3 lightPositions[4];
uniform vec3 lightColours[4];
uniform vec3 camPos;

out vec4 FragColour;

const float PI = 3.14159265359;

float DistributionGGX(vec3 _N, vec3 _H, float _roughness)
{
	// NUMERATOR
	//==========
	float alpha = _roughness * _roughness;
	float alphaSqrd = alpha * alpha;

	float num = alphaSqrd;

	// DENOMINATOR
	//============
	float NdotH = max(dot(_N, _H), 0.0);
	float NdotHSqrd = NdotH * NdotH;

	float denom = NdotHSqrd * (alphaSqrd - 1.0) + 1.0;
	float denomSqrd = denom * denom;
	denom = PI * denomSqrd; 

	// RESULT
	//=======
	return num / denom;
}

// _NdotX because this function gets called for both the 
// viewDir and lightDir dot products
float GeometrySchlickGGX(float _NdotX, float _roughness)
{
	// PREREQUISITES
	//==============
	float alpha = _roughness * _roughness;
	float k = alpha / 2;


	// NUMERATOR & DENOMINATOR
	//========================
	float num = _NdotX;
	float denom = _NdotX * (1.0 - k) + k;

	// RESULT
	//=======
	return num / denom;
}

// Smith breaks the GGX down into two parts; lightDir and viewDir.
// They both execute the same equations.
float GeometrySmith(vec3 _normVec, vec3 _viewDir, vec3 _lightDir, float _roughness)
{
	// PART ONE
	//=========
    float NdotL = max(dot(_normVec, _lightDir), 0.0);
	float ggxPartOne = GeometrySchlickGGX(NdotL, _roughness);

	// PART TWO
	//=========
	float NdotV = max(dot(_normVec, _viewDir), 0.0);
    float ggxPartTwo = GeometrySchlickGGX(NdotV, _roughness);
	
	// RESULT
	//=======
    return ggxPartOne * ggxPartTwo;
}

vec3 fresnelSchlick(float _cosTheta, vec3 _F0)
{	
	vec3 partOne = (1.0 - _F0);
	float partTwo = pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);	// Clamping prevents black spots

	return _F0 + partOne * partTwo;
}

vec3 getNormalFromMap()
{
	vec3 tangentNormal = texture(normalMap, v_TexCoord).xyz * 2.0 - 1.0;

	vec3 Q1 = dFdx(v_WorldPos);
	vec3 Q2 = dFdy(v_WorldPos);
	vec2 st1 = dFdx(v_TexCoord);
	vec2 st2 = dFdy(v_TexCoord);

	vec3 N = normalize(v_Normal);
	vec3 T = normalize(Q1 * st2.t - Q2 * st1.t);
	vec3 B = -normalize(cross(N, T));
	mat3 TBN = mat3(T, B, N);

	return normalize(TBN * tangentNormal);
}

vec3 fresnelSchlickRoughness(float _cosTheta, vec3 _F0, float _roughness)
{
    return _F0 + (max(vec3(1.0 - _roughness), _F0) - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
} 

void main()											 
{	
	vec3 albedo = pow(texture(albedoMap, v_TexCoord).rgb, vec3(2.2));
	float metallic = texture(metallicMap, v_TexCoord).r;
	float roughness = texture(roughnessMap, v_TexCoord).r;
	float ao = texture(aoMap, v_TexCoord).r;

	vec3 normVec = getNormalFromMap();
	vec3 viewDir = normalize(camPos - v_WorldPos);
	vec3 reflectDir = reflect(-viewDir, normVec);

	// F0 is surface reflection; how much the surface reflects 
	// if looking directly at the surface.
	// For non-metallic surfaces
	vec3 F0 = vec3(0.04);	// Assume most dielectric surfaces to be correct at 0.04.

	// For metallic surfaces
	F0 = mix(F0, albedo, metallic);

	// REFLECTANCE EQUATION
	//=====================
	// total radiance of the scene (Lo)
	vec3 outgoingRadiance = vec3(0.0);
	for (int i = 0; i < 4; i++)
	{
		// PER-LIGHT RADIANCE
		//===================
		vec3 lightDir = normalize(lightPositions[i] - v_WorldPos);
		vec3 halfwayVec = normalize(viewDir + lightDir);

		// INVERSE-SQUARE LAW
		// When the distance increases, the intensity decreases. 
		// When the distance decreases, the intensity increases.
		//===================
		float distance = length(lightPositions[i] - v_WorldPos);
		float intensity = 1.0 / (distance * distance);
		vec3 radiance = lightColours[i] * intensity;

		// COOK-TORRANCE BRDF
		//===================
		float NDF = DistributionGGX(normVec, halfwayVec, roughness);
		float G = GeometrySmith(normVec, viewDir, lightDir, roughness);
		vec3 F = fresnelSchlick(max(dot(halfwayVec, viewDir), 0.0), F0);	// We pass through the half-way vector and view direction to create the cosTheta for fresnel

		// NUMERATOR
		//==========
		vec3 num = NDF * G * F;
		
		// DENOMINATOR
		//============
		float denom = 4 * max(dot(normVec, lightDir), 0.0) * max(dot(normVec, viewDir), 0.0) + 0.0001;	// prevent any divide by zero

		// COOK-TORRANCE RESULT
		//=====================
		vec3 specular = num / denom;

		// LIGHT CONTRIBUTION TO END RESULT
		//=================================
		// reflection/specular fraction (kS) is equal to Fresnel
		vec3 reflection = F;
		// refraction/diffuse fraction (kD)
		vec3 refraction = vec3(1.0) - reflection;	// stops it from exceeding 1.0, preserviing the energy conservation relationship

		// If the surface is metal, we invalidate the reflection due to the absorbtion of light.
		// Metals show no diffuse colour and leave refracted or specular light. 
		refraction *= 1.0 - metallic;

		// Scale light by NdotL
		float NdotL = max(dot(normVec, lightDir), 0.0);

		// Add to outgoing radiance
		outgoingRadiance += (refraction * albedo / PI + specular) * radiance * NdotL;	// Note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again
	}

	// We use an injected version of the fresnel schlick to fix the reflection strength on rough non-metals
	vec3 F = fresnelSchlickRoughness(max(dot(normVec, viewDir), 0.0), F0, roughness);

	// Do the same as before when determining per-light contribution
	vec3 reflection = F;
	vec3 refraction = 1.0 - reflection;
	refraction *= 1.0 - metallic;

	// Retrieve the irradiance influencing the fragment
	vec3 irradiance = texture(irradianceMap, normVec).rgb;
	vec3 diffuse = irradiance * albedo;

	const float MAX_REFLECTION_LOD = 4.0;
	vec3 prefilteredColour = textureLod(prefilterMap, reflectDir, roughness * MAX_REFLECTION_LOD).rgb;
	vec2 brdf = texture(brdfLUT, vec2(max(dot(normVec, viewDir), 0.0), roughness)).rg;
	vec3 specular = prefilteredColour * (F * brdf.x + brdf.y);

	vec3 ambient = (refraction * diffuse + specular) * ao;
	
	vec3 colour = ambient + outgoingRadiance;

	// HDR tonemapping
	colour = colour / (colour + vec3(1.0));

	// Gamma correct
	colour = pow(colour, vec3(1.0/2.2));

	// FINAL RESULT
	//=============
	FragColour = vec4(colour, 1.0);
}