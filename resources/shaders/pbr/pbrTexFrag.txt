// The following code is based, and with some modifications, from :- 
// Joey de Vries (2020). Learn OpenGL [online]. [Accessed 6th November 2021].
// Available from: <https://learnopengl.com>.

#version 410

// Material properties
uniform sampler2D albedoMap;
uniform sampler2D normalMap;
uniform sampler2D metallicMap;
uniform sampler2D roughnessMap;
uniform sampler2D aoMap;
uniform sampler2D emissiveMap;

in vec3 v_WorldPos;
in vec2 v_TexCoord;
in vec3 v_Normal;

// IBL
uniform samplerCube irradianceMap;
uniform samplerCube prefilterMap;
uniform sampler2D brdfLUT;

uniform vec3 lightPositions[4];
uniform vec3 lightColours[4];
uniform vec3 camPos;

out vec4 FragColour;

const float PI = 3.14159265359;

// The following section uses equations from :-
// Brian Karis (2013). Specular BRDF Reference [online]. [Accessed 8th December 2021].
// Available from: <http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html>
float DistributionGGX(vec3 _N, vec3 _H, float _roughness)
{
	// NOMINATOR
	//==========
	float alpha = _roughness * _roughness;
	float alphaSqrd = alpha * alpha;

	float num = alphaSqrd;

	// DENOMINATOR
	//============
	float NdotH = max(dot(_N, _H), 0.0);
	float NdotHSqrd = NdotH * NdotH;

	float denom = NdotHSqrd * (alphaSqrd - 1.0) + 1.0;
	float denomSqrd = denom * denom;
	denom = PI * denomSqrd; 

	// RESULT
	//=======
	return num / denom;
}
// end of Citation

float GeometrySchlickGGX(float _NdotV, float _roughness)
{
    float r = (_roughness + 1.0);
    float k = (r*r) / 8.0;

    float nom   = _NdotV;
    float denom = _NdotV * (1.0 - k) + k;

    return nom / denom;
}

float GeometrySmith(vec3 _N, vec3 _V, vec3 _L, float _roughness)
{
    float NdotV = max(dot(_N, _V), 0.0);
    float NdotL = max(dot(_N, _L), 0.0);
    float ggx2 = GeometrySchlickGGX(NdotV, _roughness);
    float ggx1 = GeometrySchlickGGX(NdotL, _roughness);

    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float _cosTheta, vec3 _F0)
{
    return _F0 + (1.0 - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
}

vec3 getNormalFromMap()
{
	vec3 tangentNormal = texture(normalMap, v_TexCoord).xyz * 2.0 - 1.0;

	vec3 Q1 = dFdx(v_WorldPos);
	vec3 Q2 = dFdy(v_WorldPos);
	vec2 st1 = dFdx(v_TexCoord);
	vec2 st2 = dFdy(v_TexCoord);

	vec3 N = normalize(v_Normal);
	vec3 T = normalize(Q1 * st2.t - Q2 * st1.t);
	vec3 B = -normalize(cross(N, T));
	mat3 TBN = mat3(T, B, N);

	return normalize(TBN * tangentNormal);
}

vec3 fresnelSchlickRoughness(float _cosTheta, vec3 _F0, float _roughness)
{
    return _F0 + (max(vec3(1.0 - _roughness), _F0) - _F0) * pow(clamp(1.0 - _cosTheta, 0.0, 1.0), 5.0);
} 

void main()											 
{	
	vec3 albedo = pow(texture(albedoMap, v_TexCoord).rgb, vec3(2.2));
	float metallic = texture(metallicMap, v_TexCoord).r;
	float roughness = texture(roughnessMap, v_TexCoord).r;
	float ao = texture(aoMap, v_TexCoord).r;
	vec3 emissive = pow(texture(emissiveMap, v_TexCoord).rgb, vec3(2.2));

	vec3 normVec = getNormalFromMap();
	vec3 viewDir = normalize(camPos - v_WorldPos);
	vec3 reflectDir = reflect(-viewDir, normVec);

	// F0 is surface reflection; how much the surface reflects 
	// if looking directly at the surface.
	// For non-metallic surfaces
	vec3 F0 = vec3(0.04);	// Assume most dielectric surfaces to be correct at 0.04.

	// For metallic surfaces
	F0 = mix(F0, albedo, metallic);

	// REFLECTANCE EQUATION
	//=====================
	// total radiance of the scene (Lo)
	vec3 outgoingRadiance = vec3(0.0);
	for (int i = 0; i < 4; i++)
	{
		// PER-LIGHT RADIANCE
		//===================
		vec3 lightDir = normalize(lightPositions[i] - v_WorldPos);
		vec3 halfwayVec = normalize(viewDir + lightDir);

		// INVERSE-SQUARE LAW
		// When the distance increases, the intensity decreases. 
		// When the distance decreases, the intensity increases.
		//===================
		float distance = length(lightPositions[i] - v_WorldPos);
		float intensity = 1.0 / (distance * distance);
		vec3 radiance = lightColours[i] * intensity;

		// COOK-TORRANCE BRDF
		//===================
		float NDF = DistributionGGX(normVec, halfwayVec, roughness);
		float G = GeometrySmith(normVec, viewDir, lightDir, roughness);
		vec3 F = fresnelSchlick(max(dot(halfwayVec, viewDir), 0.0), F0);	// We pass through the half-way vector and view direction to create the cosTheta for fresnel

		// NUMERATOR
		//==========
		vec3 num = NDF * G * F;
		
		// DENOMINATOR
		//============
		float denom = 4 * max(dot(normVec, lightDir), 0.0) * max(dot(normVec, viewDir), 0.0) + 0.0001;	// prevent any divide by zero

		// COOK-TORRANCE RESULT
		//=====================
		vec3 specular = num / denom;

		// LIGHT CONTRIBUTION TO END RESULT
		//=================================
		// reflection/specular fraction (kS) is equal to Fresnel
		vec3 reflection = F;
		// refraction/diffuse fraction (kD)
		vec3 refraction = vec3(1.0) - reflection;	// stops it from exceeding 1.0, preserviing the energy conservation relationship

		// If the surface is metal, we invalidate the reflection due to the absorbtion of light.
		// Metals show no diffuse colour and leave refracted or specular light. 
		refraction *= 1.0 - metallic;

		// Scale light by NdotL
		float NdotL = max(dot(normVec, lightDir), 0.0);

		// Add to outgoing radiance
		outgoingRadiance += (refraction * albedo / PI + specular) * radiance * NdotL;	// Note that we already multiplied the BRDF by the Fresnel (kS) so we won't multiply by kS again
	}
}